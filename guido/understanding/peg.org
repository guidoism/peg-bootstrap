This is my first attempt at literate programming with Org Mode where
I'm trying to create a self-compiling PEG parser.

* The rules

#+TBLNAME: rules
| sp                | <- | ' '                                                     |    |                          |   |
|                   | /  | '\n'                                                    |    |                          |   |
|                   | /  | '\t'                                                    |    |                          | . |
| sps               | <- | sp sps                                                  |    |                          |   |
|                   | /  |                                                         |    |                          | . |
| rule              | <- | n: name sps '<-' sps body: choice '.' sps               | -> | rule_template            | . |
| grammar           | <- | sps r: rule g: grammar                                  | -> | grammar_template1        |   |
|                   | /  | sps r: rule                                             | -> | grammar_template2        | . |
| meta              | <- | '!'                                                     |    |                          |   |
|                   | /  | '\''                                                    |    |                          |   |
|                   | /  | '<-'                                                    |    |                          |   |
|                   | /  | '/'                                                     |    |                          |   |
|                   | /  | '.'                                                     |    |                          |   |
|                   | /  | '('                                                     |    |                          |   |
|                   | /  | ')'                                                     |    |                          |   |
|                   | /  | ':'                                                     |    |                          |   |
|                   | /  | '->'                                                    |    |                          | . |
| name              | <- | c: namechar n: name                                     | -> | name_template            |   |
|                   | /  | namechar                                                |    |                          | . |
| namechar          | <- | !meta !sp char                                          |    |                          | . |
| term              | <- | labeled                                                 |    |                          |   |
|                   | /  | nonterminal                                             |    |                          |   |
|                   | /  | string                                                  |    |                          |   |
|                   | /  | negation                                                |    |                          |   |
|                   | /  | parenthesized                                           |    |                          | . |
| nonterminal       | <- | n: name sps                                             | -> | nonterminal_template     | . |
| labeled           | <- | label: name sps ':' sps value: term                     | -> | labeled_template         | . |
| sequence          | <- | foo: term  bar: sequence                                | -> | sequence_template1       |   |
|                   | /  | result_expression                                       |    |                          |   |
|                   | /  |                                                         | -> | sequence_template2       | . |
| string            | <- | '\'' s: stringcontents '\'' sps                         | -> | string_template          | . |
| stringcontents    | <- | !'\\' !'\'' c: char s: stringcontents                   | -> | stringcontents_template1 |   |
|                   | /  | b: '\\' c: char s: stringcontents                       | -> | stringcontents_template2 |   |
|                   | /  |                                                         | -> | stringcontents_template3 | . |
| choice            | <- | a: sequence '/' sps  b: choice                          | -> | choice_template          |   |
|                   | /  | sequence                                                |    |                          | . |
| negation          | <- | '!' sps t: term                                         | -> | negation_template        | . |
| result_expression | <- | '->' sps result: expr sps                               | -> | result_expr_template     | . |
| expr              | <- | '(' sps e: exprcontents ')'                             | -> | expr_template            | . |
| exprcontents      | <- | c: (!'(' !')' (location / char) / expr) e: exprcontents | -> | exprcontents_template1   |   |
|                   | /  |                                                         | -> | exprcontents_template2   | . |
| location          | <- | 'ยง' n: name                                             | -> | location_template        | . |
| parenthesized     | <- | '(' sps body: choice ')' sps                            | -> | (body)                   | . |


* Helper scripts to tie everything together at the end
#+PROPERTY: header-args:python :var filename=(buffer-file-name)

#+NAME: pegfile
#+BEGIN_SRC python :var rules=rules :noweb yes
  <<js_src_blocks>>
  name_size = max(len(r[0]) for r in rules)
  out = []
  for (name, larrow, body, rarrow, action, end) in rules:
      if action and action[0] != '(':
	  action = blocks.get(action) or 'NOT FOUND'
      out.append(f"{name.ljust(name_size)} {larrow} {body} {rarrow} {action} {end}")
  output = '\n'.join(out)
  output = output.replace('sps', '_')
  open('literate.a.peg', 'w').write(output)

  out = []
  for (name, larrow, body, rarrow, action, end) in rules:
      if action and action[0] != '(':
	  b_action = f'B.{action}'
	  action = blocks.get(b_action) or blocks.get(action) or 'NOT FOUND'
      out.append(f"{name.ljust(name_size)} {larrow} {body} {rarrow} {action} {end}")
  output = '\n'.join(out)
  output = output.replace('sps', '_')
  open('literate.b.peg', 'w').write(output)

  out = []
  for (name, larrow, body, rarrow, action, end) in rules:
      if action and action[0] != '(':
	  b_action = f'C.{action}'
	  action = blocks.get(b_action) or blocks.get(action) or 'NOT FOUND'
      out.append(f"{name.ljust(name_size)} {larrow} {body} {rarrow} {action} {end}")
  output = '\n'.join(out)
  output = output.replace('sps', '_')
  open('literate.c.peg', 'w').write(output)

  out = []
  for (name, larrow, body, rarrow, action, end) in rules:
      if action and action[0] != '(':
	  b_action = f'D.{action}'
	  action = blocks.get(b_action) or blocks.get(action) or 'NOT FOUND'
      out.append(f"{name.ljust(name_size)} {larrow} {body} {rarrow} {action} {end}")
  output = '\n'.join(out)
  output = output.replace('sps', '_')
  open('literate.d.peg', 'w').write(output)

  return output
#+END_SRC

The C-series templates move the variables from Javascript
function-scoped `var`-style variables to a function-scoped dictionary
called `vars` which will be used by the `format` function.

After these templates are run then we will have a parser than can
accept templates that make use of the vars dictionary, which is what
the D-series templates will do.

TODO: Use the vars dictionary
TODO: Keep all strings in a buffer and refer to them with (index, length) tuples.


#+RESULTS: pegfile
#+begin_example
sp                <- ' '   
                  / '\n'   
                  / '\t'   .
_               <- sp _   
                  /    .
rule              <- n: name _ '<-' _ body: choice '.' _ -> (format(['function parse_',
           vars['n'],
           '(input, pos) { let state = { pos: pos }; let stack = []; ',
           'let vars = {}',
           vars['body'],
           ' return state; }']))
 .
grammar           <- _ r: rule g: grammar -> (`${r}\n${g}`)
 
                  / _ r: rule -> ('// This is from a template in peg.org:\n' + r +
   ` function parse_char(input, pos) {
     if (pos >= input.length) return null;
     return { pos: pos + 1, val: input.charAt(pos) };
   }
   function literal(input, pos, string) {
     if (input.substr(pos, string.length) === string) {
       return { pos: pos + string.length, val: string };
     } else return null;
   }
   let format = (parts) => parts.join('')
   var fs = require(\'fs\');
   var grammarfile = process.argv.slice(2)[0];
   fs.readFile(grammarfile, function(err, data) {
       if (err) {
	   throw err; 
       }
       var out = parse_grammar(data.toString(), 0);
       console.log(out.val);
   });`)
 .
meta              <- '!'   
                  / '\''   
                  / '<-'   
                  / '/'   
                  / '.'   
                  / '('   
                  / ')'   
                  / ':'   
                  / '->'   .
name              <- c: namechar n: name -> (c + n)
 
                  / namechar   .
namechar          <- !meta !sp char   .
term              <- labeled   
                  / nonterminal   
                  / string   
                  / negation   
                  / parenthesized   .
nonterminal       <- n: name _ -> (`state = parse_${n}(input, state.pos);\n`)
 .
labeled           <- label: name _ ':' _ value: term -> (format([vars['value'],
           ' if (state) { vars["',
           vars['label'],
           '"] = state.val; }']))
 .
sequence          <- foo: term  bar: sequence -> (format([vars['foo'],
           ' if (valid) { ',
           vars['bar'],
           ' } ']))
 
                  / result_expression   
                  /  -> ('')
 .
string            <- '\'' s: stringcontents '\'' _ -> (format(['state = literal(input, state.pos, \"',
           vars['s'],
           '\");']))
 .
stringcontents    <- !'\\' !'\'' c: char s: stringcontents -> (c + s)
 
                  / b: '\\' c: char s: stringcontents -> (b + c + s)
 
                  /  -> ('')
 .
choice            <- a: sequence '/' _  b: choice -> (format(['stack.push(state); ',
	      vars['a'],
	      ' if (!state) {state = stack.pop(); ',
	      vars['b'],
	      '} else { stack.pop(); }']))
 
                  / sequence   .
negation          <- '!' _ t: term -> (format([' stack.push(state);',
            vars['t'], 
            'if (state) { stack.pop(); state = null; }',
            'else { state = stack.pop(); }']))
 .
result_expression <- '->' _ result: expr _ -> (format(['if (valid) { state.val = ',
           vars['result'],
           '; }']))
 .
expr              <- '(' _ e: exprcontents ')' -> ('(' + e + ')')
 .
exprcontents      <- c: (!'(' !')' (location / char) / expr) e: exprcontents -> (c + e)
 
                  /  -> ('')
 .
location          <- 'ยง' n: name -> ('POOP')
 .
parenthesized     <- '(' _ body: choice ')' _ -> (body) .
#+end_example


#+NAME: guido
#+BEGIN_SRC python :var rules=rules
  import re
  out = ['\input cwebmac \halign{\strut\hfil#\hfil\quad&#\hfil\quad&#\hfil\quad&#\hfil\quad&\hfil#\cr']
  for (name, larrow, body, rarrow, action, end) in rules:
      if larrow == '<-':
	  larrow = '\\leftarrow '
      if rarrow == '->':
	  rarrow = '\\rightarrow '
      body = body.replace('\\', '\\\\')
      #body = re.sub(r"'(\\\'|[^']+)'", r"\\vb{\\tt '\1'}", body)
      out.append(f"{name} & {larrow} & {body} & {rarrow} & {end} \cr")
  out.append('}\n\\bye\n')
  output = '\n'.join(out)
  open('output.tex', 'w').write(output)
  return output
#+END_SRC

#+RESULTS: guido
#+begin_example
\input cwebmac \halign{\strut\hfil#\hfil\quad&#\hfil\quad&#\hfil\quad&#\hfil\quad&\hfil#\cr
sp & \leftarrow  & ' ' &  &  \cr
 & / & '\\n' &  &  \cr
 & / & '\\t' &  & . \cr
sps & \leftarrow  & sp sps &  &  \cr
 & / &  &  & . \cr
rule & \leftarrow  & n: name sps '<-' sps body: choice '.' sps & \rightarrow  & . \cr
grammar & \leftarrow  & sps r: rule g: grammar & \rightarrow  &  \cr
 & / & sps r: rule & \rightarrow  & . \cr
meta & \leftarrow  & '!' &  &  \cr
 & / & '\\'' &  &  \cr
 & / & '<-' &  &  \cr
 & / & '/' &  &  \cr
 & / & '.' &  &  \cr
 & / & '(' &  &  \cr
 & / & ')' &  &  \cr
 & / & ':' &  &  \cr
 & / & '->' &  & . \cr
name & \leftarrow  & c: namechar n: name & \rightarrow  &  \cr
 & / & namechar &  & . \cr
namechar & \leftarrow  & !meta !sp char &  & . \cr
term & \leftarrow  & labeled &  &  \cr
 & / & nonterminal &  &  \cr
 & / & string &  &  \cr
 & / & negation &  &  \cr
 & / & parenthesized &  & . \cr
nonterminal & \leftarrow  & n: name sps & \rightarrow  & . \cr
labeled & \leftarrow  & label: name sps ':' sps value: term & \rightarrow  & . \cr
sequence & \leftarrow  & foo: term  bar: sequence & \rightarrow  &  \cr
 & / & resultexpression &  &  \cr
 & / &  & \rightarrow  & . \cr
string & \leftarrow  & '\\'' s: stringcontents '\\'' sps & \rightarrow  & . \cr
stringcontents & \leftarrow  & !'\\\\' !'\\'' c: char s: stringcontents & \rightarrow  &  \cr
 & / & b: '\\\\' c: char s: stringcontents & \rightarrow  &  \cr
 & / &  & \rightarrow  & . \cr
choice & \leftarrow  & a: sequence '/' sps  b: choice & \rightarrow  &  \cr
 & / & sequence &  & . \cr
negation & \leftarrow  & '!' sps t: term & \rightarrow  & . \cr
resultexpression & \leftarrow  & '->' sps result: expr sps & \rightarrow  & . \cr
expr & \leftarrow  & '(' sps e: exprcontents ')' & \rightarrow  & . \cr
exprcontents & \leftarrow  & c: (!'(' !')' char / expr)  e: exprcontents & \rightarrow  &  \cr
 & / &  & \rightarrow  & . \cr
parenthesized & \leftarrow  & '(' sps body: choice ')' sps & \rightarrow  & . \cr
}
\bye
#+end_example

We need a way to get the templates that have been broken out into
source blocks in this document. There's probably a better way, but the
easiest thing I could figure out was to read the current file into
memory and use regexes to get at each of the source blocks. This is
probably pretty fragile so we should consider something better.

#+NAME: js_src_blocks
#+BEGIN_SRC python
  import re
  this = open(filename).read()
  blocks = dict(re.findall(r'#\+NAME:\s*(\S+)\s+#\+BEGIN_SRC js\s+(.+?)#\+END_SRC', this, re.MULTILINE|re.DOTALL))
#+END_SRC


* Action Templates

  The (high-level) operations our parser needs to operate are:

  - Function calls (Jumping to labels)
  - Recursion (can be implemented by hand with stacks)
  - Stacks to save state between alternatives
  - String templating with variable interpolation
  - If statements
  - Saving of named variables during a function lifetime
  - Invalid state
  - Matching string literals
  - Concatenation of strings
  - Reading/writing, input/output
  
  Note: The `B`-series templates are made to do string interpolation in a way
  closer to other languages and easier to port to C and assembly.

  Note: The `C`-series templates generate javascript code which on the next
  pass will generate C code. In order for that C code to be able to generate
  itself we will need a `D`-series which is slightly tweaked to use C string
  formating rather than javascript string templating.

  `node literate.6.js literate.c.peg > literate.7.js`

  In this example literate.7.js is a javascript program that will generate
  a C parser.
  
  
** rule_template

   Each rule is represented and generated as a single function. These
   function need to support recursive and mutually-recusive calls.

   Upon entry, each invocation saves the current position and creates
   a new stack for itself.

   Then the generated body is run and whatever the state is at the end
   is returned to the caller.
   
#+NAME: rule_template
#+BEGIN_SRC js
(`// This is from a template in b.peg
function parse_${n}(input, pos) {
      var state = { pos: pos };
      var stack = [];
      ${body}
      return state;
}`)
#+END_SRC

#+NAME: B.rule_template
#+BEGIN_SRC js
(format(['function parse_', n, '(input, pos) { var state = { pos: pos }; var stack = []; ',
         body, ' return state; }']))
#+END_SRC

#+NAME: CLANG.rule_template
#+BEGIN_SRC js
(format(['State parse_', n, '(str input, int pos) { State state = { .pos=pos }; Stack stack = {0}; ',
         body, ' return state; }']))
#+END_SRC

#+NAME: C.rule_template
#+BEGIN_SRC js
  (format(['function parse_',
           n,
           '(input, pos) { let state = { pos: pos }; let stack = []; ',
           'let vars = {}',
           body,
           ' return state; }']))
#+END_SRC

#+NAME: D.rule_template
#+BEGIN_SRC js
  (format(['function parse_',
           vars['n'],
           '(input, pos) { let state = { pos: pos }; let stack = []; ',
           'let vars = {}',
           vars['body'],
           ' return state; }']))
#+END_SRC

labeled_template:
#+NAME: labeled_template
#+BEGIN_SRC js
(`${value} if (state) { var ${label} = state.val; }\n`)
#+END_SRC

#+NAME: B.labeled_template
#+BEGIN_SRC js
(format([value, ' if (state) { var ', label, ' = state.val; }']))
#+END_SRC

#+NAME: CLANG.labeled_template
#+BEGIN_SRC js
(format([value, ' if (valid) { var("', label, '", state.val); }']))
#+END_SRC

#+NAME: C.labeled_template
#+BEGIN_SRC js
  (format([value,
           ' if (state) { vars["',
           label,
           '"] = state.val; }']))
#+END_SRC

#+NAME: D.labeled_template
#+BEGIN_SRC js
  (format([vars['value'],
           ' if (state) { vars["',
           vars['label'],
           '"] = state.val; }']))
#+END_SRC

result_expr_template:
#+NAME: result_expr_template
#+BEGIN_SRC js
(`if (state) state.val = ${result};\n`)
#+END_SRC

#+NAME: B.result_expr_template
#+BEGIN_SRC js
(format(['if (state) { state.val = ', result, '; }']))
#+END_SRC

#+NAME: C.result_expr_template
#+BEGIN_SRC js
  (format(['if (valid) { state.val = ',
           result,
           '; }']))
#+END_SRC

#+NAME: D.result_expr_template
#+BEGIN_SRC js
  (format(['if (valid) { state.val = ',
           vars['result'],
           '; }']))
#+END_SRC

negation_template:
#+NAME: negation_template
#+BEGIN_SRC js
(` stack.push(state);
   ${t}
   if (state) {
     stack.pop();
     state = null;
   } else { state = stack.pop(); }`)
#+END_SRC

#+NAME: B.negation_template
#+BEGIN_SRC js
  (format([' stack.push(state);', t, 
	   'if (state) { stack.pop(); state = null; }',
	   'else { state = stack.pop(); }']))
#+END_SRC

#+NAME: CLANG.negation_template
#+BEGIN_SRC js
  (format([' push(state);', t, 
	   'if (valid) { pop(); state.null = true; }',
	   'else { state = pop(); }']))
#+END_SRC

#+NAME: C.negation_template
#+BEGIN_SRC js
   (format([' stack.push(state);',
            t, 
            'if (state) { stack.pop(); state = null; }',
            'else { state = stack.pop(); }']))
#+END_SRC

#+NAME: D.negation_template
#+BEGIN_SRC js
   (format([' stack.push(state);',
            vars['t'], 
            'if (state) { stack.pop(); state = null; }',
            'else { state = stack.pop(); }']))
#+END_SRC

choice_template:
#+NAME: choice_template
#+BEGIN_SRC js
(`stack.push(state); ${a} if (!state) {state = stack.pop(); ${b}} else { stack.pop(); }`)
#+END_SRC

#+NAME: B.choice_template
#+BEGIN_SRC js
     (format(['stack.push(state); ',
	      a,
	      ' if (!state) {state = stack.pop(); ',
	      b,
	      '} else { stack.pop(); }']))
#+END_SRC

#+NAME: CLANG.choice_template
#+BEGIN_SRC js
     (format(['push(state); ',
	      a,
	      ' if (invalid) { state = pop(); ',
	      b,
	      '} else { pop(); }']))
#+END_SRC

#+NAME: C.choice_template
#+BEGIN_SRC js
     (format(['stack.push(state); ',
	      a,
	      ' if (!state) {state = stack.pop(); ',
	      b,
	      '} else { stack.pop(); }']))
#+END_SRC

#+NAME: D.choice_template
#+BEGIN_SRC js
     (format(['stack.push(state); ',
	      vars['a'],
	      ' if (!state) {state = stack.pop(); ',
	      vars['b'],
	      '} else { stack.pop(); }']))
#+END_SRC

string_template:
#+NAME: string_template
#+BEGIN_SRC js
(`state = literal(input, state.pos, '${s}');\n`)
#+END_SRC

#+NAME: B.string_template
#+BEGIN_SRC js
(format(['state = literal(input, state.pos, \'', s, '\');']))
#+END_SRC

#+NAME: C.string_template
#+BEGIN_SRC js
  (format(['state = literal(input, state.pos, \"',
           s,
           '\");']))
#+END_SRC

#+NAME: D.string_template
#+BEGIN_SRC js
  (format(['state = literal(input, state.pos, \"',
           vars['s'],
           '\");']))
#+END_SRC

sequence_template1:
#+NAME: sequence_template1
#+BEGIN_SRC js
(`${foo}  if (state) { ${bar} }\n`)
#+END_SRC

#+NAME: B.sequence_template1
#+BEGIN_SRC js
(format([foo, ' if (state) { ', bar, ' } ']))
#+END_SRC

#+NAME: C.sequence_template1
#+BEGIN_SRC js
  (format([foo,
           ' if (valid) { ',
           bar,
           ' } ']))
#+END_SRC

#+NAME: D.sequence_template1
#+BEGIN_SRC js
  (format([vars['foo'],
           ' if (valid) { ',
           vars['bar'],
           ' } ']))
#+END_SRC

sequence_template2:
#+NAME: sequence_template2
#+BEGIN_SRC js
('')
#+END_SRC

stringcontents_template1:
#+NAME: stringcontents_template1
#+BEGIN_SRC js
(c + s)
#+END_SRC

stringcontents_template2:
#+NAME: stringcontents_template2
#+BEGIN_SRC js
(b + c + s)
#+END_SRC

stringcontents_template3:
#+NAME: stringcontents_template3
#+BEGIN_SRC js
('')
#+END_SRC

expr_template:
#+NAME: expr_template
#+BEGIN_SRC js
('(' + e + ')')
#+END_SRC

exprcontents_template1:
#+NAME: exprcontents_template1
#+BEGIN_SRC js
(c + e)
#+END_SRC

exprcontents_template2:
#+NAME: exprcontents_template2
#+BEGIN_SRC js
('')
#+END_SRC

nonterminal_template:
#+NAME: nonterminal_template
#+BEGIN_SRC js
(`state = parse_${n}(input, state.pos);\n`)
#+END_SRC

#+NAME: B.nonterminal_template
#+BEGIN_SRC js
(format(['state = parse_', n, '(input, state.pos);']))
#+END_SRC

grammar_template1:
#+NAME: grammar_template1
#+BEGIN_SRC js
(`${r}\n${g}`)
#+END_SRC

#+NAME: B.grammar_template1
#+BEGIN_SRC js
(format([r, ' ', g]))
#+END_SRC

grammar_template2:
#+NAME: grammar_template2
#+BEGIN_SRC js
  ('// This is from a template in peg.org:\n' + r +
   ` function parse_char(input, pos) {
     if (pos >= input.length) return null;
     return { pos: pos + 1, val: input.charAt(pos) };
   }
   function literal(input, pos, string) {
     if (input.substr(pos, string.length) === string) {
       return { pos: pos + string.length, val: string };
     } else return null;
   }
   let format = (parts) => parts.join('')
   var fs = require(\'fs\');
   var grammarfile = process.argv.slice(2)[0];
   fs.readFile(grammarfile, function(err, data) {
       if (err) {
	   throw err; 
       }
       var out = parse_grammar(data.toString(), 0);
       console.log(out.val);
   });`)
#+END_SRC

#+NAME: C.grammar_template2
#+BEGIN_SRC js
(format([r, "\n// END\n"]))
#+END_SRC js

name_template:
#+NAME: name_template
#+BEGIN_SRC js
(c + n)
#+END_SRC

location_template:
#+NAME: location_template
#+BEGIN_SRC js
('POOP')
#+END_SRC

* C Helper Functions

#+NAME: c_include
#+BEGIN_SRC c

  #include <stdbool.h>
  #include <stdio.h>
  #include <stdlib.h>
  #define GB_STRING_IMPLEMENTATION
  #include "gb_string.h"

  typedef gbString str;

  typedef struct State {
      int pos;
      str val;
      bool null;
  } State;

  typedef struct Stack {
      State states[32];
      int n;
  } Stack;

  typedef struct Variable {
      str key;
      str value;
  } Variable;

  typedef struct Variables {
      Variable items[32];
      int n;
  } Variables;

  #define valid (!state.null)
  #define invalid (state.null)
  #define var(key, value) vars.items[vars.n++] = (Variable){.key=copy(key), .value=copy(value)};
  #define push(o) stack.states[stack.n++] = o
  #define pop() stack.states[--stack.n];

#+END_SRC

