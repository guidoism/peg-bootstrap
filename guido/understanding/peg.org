This is my first attempt at literate programming with Org Mode where
I'm trying to create a self-compiling PEG parser.

#+PROPERTY: header-args:python :var filename=(buffer-file-name)

#+NAME: pegfile
#+BEGIN_SRC python :var rules=rules
  import re
  #ORDER = ["sp", "sps", "rule", "grammar", "meta", "name", "namechar", "term", "nonterminal", "labeled", "sequence", "string", "stringcontents", "choice", "negation", "result_expression", "expr", "exprcontents", "parenthesized"]

  this = open(filename).read()
  m = dict(re.findall(r'#\+NAME:\s*(\S+)\s+#\+BEGIN_SRC js\s+(.+?)#\+END_SRC', this, re.MULTILINE|re.DOTALL))
  open('/tmp/poop.txt', 'w').write(str(m))

  name_size = max(len(r[0]) for r in rules)
  out = []
  for (name, larrow, body, rarrow, action, end) in rules:
      if action and action[0] != '(':
	  action = m.get(action) or 'NOT FOUND'
      out.append(f"{name.ljust(name_size)} {larrow} {body} {rarrow} {action} {end}")
  output = '\n'.join(out)
  open('output.txt', 'w').write(output)
  return output
#+END_SRC

#+RESULTS: pegfile
#+begin_example
sp                <- ' '   
                  / '\n'   
                  / '\t'   .
sps               <- sp sps   
                  /    .
rule              <- n: name sps '<-' sps body: choice '.' sps -> (`// This is from a template in b.peg
function parse_${n}(input, pos) {
      var state = { pos: pos };
      var stack = [];
      // Not sure where this body is coming from
      ${body}
      return state;
}`)
 .
grammar           <- sps r: rule g: grammar -> (`${r}\n${g}`)
 
                  / sps r: rule -> (`// This is from a template in peg.org:
 ${r}
 function parse_char(input, pos) {
   if (pos >= input.length) return null;
   return { pos: pos + 1, val: input.charAt(pos) };
 }
 function literal(input, pos, string) {
   if (input.substr(pos, string.length) === string) {
     return { pos: pos + string.length, val: string };
   } else return null;
 }
 var fs = require(\'fs\');
 var grammarfile = process.argv.slice(2)[0];
 fs.readFile(grammarfile, function(err, data) {
     if (err) {
         throw err; 
     }
     var out = parse_grammar(data.toString(), 0);
     console.log(out.val);
 });`)
 .
meta              <- '!'   
                  / '\''   
                  / '<-'   
                  / '/'   
                  / '.'   
                  / '('   
                  / ')'   
                  / ':'   
                  / '->'   .
name              <- c: namechar n: name -> (c + n) 
                  / namechar   .
namechar          <- !meta !sp char   .
term              <- labeled   
                  / nonterminal   
                  / string   
                  / negation   
                  / parenthesized   .
nonterminal       <- n: name sps -> (`  state = parse_${n}(input, state.pos);\n`)
 .
labeled           <- label: name sps ':' sps value: term -> (`${value} if (state) var ${label} = state.val;\n`)
 .
sequence          <- foo: term  bar: sequence -> (`${foo}  if (state) { ${bar} }\n`)
 
                  / result_expression   
                  /  -> ('') .
string            <- '\'' s: stringcontents '\'' sps -> (`  state = literal(input, state.pos, '${s}');\n`)
 .
stringcontents    <- !'\\' !'\'' c: char s: stringcontents -> (c + s) 
                  / b: '\\' c: char s: stringcontents -> (b + c + s) 
                  /  -> ('') .
choice            <- a: sequence '/' sps  b: choice -> (`  stack.push(state); ${a} if (!state) {state = stack.pop(); ${b}} else { stack.pop(); }`)
 
                  / sequence   .
negation          <- '!' sps t: term -> (`stack.push(state);
   ${t}
   if (state) {
     stack.pop();
     state = null;
   } else { state = stack.pop(); }`)
 .
result_expression <- '->' sps result: expr sps -> (`if (state) state.val = ${result};\n`)
 .
expr              <- '(' sps e: exprcontents ')' -> (`(${e})`) .
exprcontents      <- c: (!'(' !')' char / expr)  e: exprcontents -> (c + e) 
                  /  -> ('') .
parenthesized     <- '(' sps body: choice ')' sps -> (body) .
#+end_example


#+NAME: guido
#+BEGIN_SRC python :var rules=rules
  import re
  out = ['\input cwebmac \halign{\strut\hfil#\hfil\quad&#\hfil\quad&#\hfil\quad&#\hfil\quad&\hfil#\cr']
  for (name, larrow, body, rarrow, action, end) in rules:
      if larrow == '<-':
	  larrow = '\\leftarrow '
      if rarrow == '->':
	  rarrow = '\\rightarrow '
      body = body.replace('\\', '\\\\')
      #body = re.sub(r"'(\\\'|[^']+)'", r"\\vb{\\tt '\1'}", body)
      out.append(f"{name} & {larrow} & {body} & {rarrow} & {end} \cr")
  out.append('}\n\\bye\n')
  output = '\n'.join(out)
  open('output.tex', 'w').write(output)
  return output
#+END_SRC

#+RESULTS: guido
#+begin_example
\input cwebmac \halign{\strut\hfil#\hfil\quad&#\hfil\quad&#\hfil\quad&#\hfil\quad&\hfil#\cr
sp & \leftarrow  & ' ' &  &  \cr
 & / & '\\n' &  &  \cr
 & / & '\\t' &  & . \cr
sps & \leftarrow  & sp sps &  &  \cr
 & / &  &  & . \cr
rule & \leftarrow  & n: name sps '<-' sps body: choice '.' sps & \rightarrow  & . \cr
grammar & \leftarrow  & sps r: rule g: grammar & \rightarrow  &  \cr
 & / & sps r: rule & \rightarrow  & . \cr
meta & \leftarrow  & '!' &  &  \cr
 & / & '\\'' &  &  \cr
 & / & '<-' &  &  \cr
 & / & '/' &  &  \cr
 & / & '.' &  &  \cr
 & / & '(' &  &  \cr
 & / & ')' &  &  \cr
 & / & ':' &  &  \cr
 & / & '->' &  & . \cr
name & \leftarrow  & c: namechar n: name & \rightarrow  &  \cr
 & / & namechar &  & . \cr
namechar & \leftarrow  & !meta !sp char &  & . \cr
term & \leftarrow  & labeled &  &  \cr
 & / & nonterminal &  &  \cr
 & / & string &  &  \cr
 & / & negation &  &  \cr
 & / & parenthesized &  & . \cr
nonterminal & \leftarrow  & n: name sps & \rightarrow  & . \cr
labeled & \leftarrow  & label: name sps ':' sps value: term & \rightarrow  & . \cr
sequence & \leftarrow  & foo: term  bar: sequence & \rightarrow  &  \cr
 & / & resultexpression &  &  \cr
 & / &  & \rightarrow  & . \cr
string & \leftarrow  & '\\'' s: stringcontents '\\'' sps & \rightarrow  & . \cr
stringcontents & \leftarrow  & !'\\\\' !'\\'' c: char s: stringcontents & \rightarrow  &  \cr
 & / & b: '\\\\' c: char s: stringcontents & \rightarrow  &  \cr
 & / &  & \rightarrow  & . \cr
choice & \leftarrow  & a: sequence '/' sps  b: choice & \rightarrow  &  \cr
 & / & sequence &  & . \cr
negation & \leftarrow  & '!' sps t: term & \rightarrow  & . \cr
resultexpression & \leftarrow  & '->' sps result: expr sps & \rightarrow  & . \cr
expr & \leftarrow  & '(' sps e: exprcontents ')' & \rightarrow  & . \cr
exprcontents & \leftarrow  & c: (!'(' !')' char / expr)  e: exprcontents & \rightarrow  &  \cr
 & / &  & \rightarrow  & . \cr
parenthesized & \leftarrow  & '(' sps body: choice ')' sps & \rightarrow  & . \cr
}
\bye
#+end_example


#+TBLNAME: rules
| sp                | <- | ' '                                         |    |                      |   |
|                   | /  | '\n'                                        |    |                      |   |
|                   | /  | '\t'                                        |    |                      | . |
| sps               | <- | sp sps                                      |    |                      |   |
|                   | /  |                                             |    |                      | . |
| rule              | <- | n: name sps '<-' sps body: choice '.' sps   | -> | rule_template        | . |
| grammar           | <- | sps r: rule g: grammar                      | -> | grammar_template1    |   |
|                   | /  | sps r: rule                                 | -> | grammar_template2    | . |
| meta              | <- | '!'                                         |    |                      |   |
|                   | /  | '\''                                        |    |                      |   |
|                   | /  | '<-'                                        |    |                      |   |
|                   | /  | '/'                                         |    |                      |   |
|                   | /  | '.'                                         |    |                      |   |
|                   | /  | '('                                         |    |                      |   |
|                   | /  | ')'                                         |    |                      |   |
|                   | /  | ':'                                         |    |                      |   |
|                   | /  | '->'                                        |    |                      | . |
| name              | <- | c: namechar n: name                         | -> | (c + n)              |   |
|                   | /  | namechar                                    |    |                      | . |
| namechar          | <- | !meta !sp char                              |    |                      | . |
| term              | <- | labeled                                     |    |                      |   |
|                   | /  | nonterminal                                 |    |                      |   |
|                   | /  | string                                      |    |                      |   |
|                   | /  | negation                                    |    |                      |   |
|                   | /  | parenthesized                               |    |                      | . |
| nonterminal       | <- | n: name sps                                 | -> | nonterminal_template | . |
| labeled           | <- | label: name sps ':' sps value: term         | -> | labeled_template     | . |
| sequence          | <- | foo: term  bar: sequence                    | -> | sequence_template1   |   |
|                   | /  | result_expression                           |    |                      |   |
|                   | /  |                                             | -> | ('')                 | . |
| string            | <- | '\'' s: stringcontents '\'' sps             | -> | string_template      | . |
| stringcontents    | <- | !'\\' !'\'' c: char s: stringcontents       | -> | (c + s)              |   |
|                   | /  | b: '\\' c: char s: stringcontents           | -> | (b + c + s)          |   |
|                   | /  |                                             | -> | ('')                 | . |
| choice            | <- | a: sequence '/' sps  b: choice              | -> | choice_template      |   |
|                   | /  | sequence                                    |    |                      | . |
| negation          | <- | '!' sps t: term                             | -> | negation_template    | . |
| result_expression | <- | '->' sps result: expr sps                   | -> | result_expr_template | . |
| expr              | <- | '(' sps e: exprcontents ')'                 | -> | (`(${e})`)           | . |
| exprcontents      | <- | c: (!'(' !')' char / expr)  e: exprcontents | -> | (c + e)              |   |
|                   | /  |                                             | -> | ('')                 | . |
| parenthesized     | <- | '(' sps body: choice ')' sps                | -> | (body)               | . |



#+TBLNAME: actions
| result_expr_template | (`if (state) state.val = ${result};\n`)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| negation_template    | (`stack.push(state); ${t} if (state) { stack.pop(); state = null; } else { state = stack.pop(); }`)                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| choice_template      | (`  stack.push(state); ${a} if (!state) {state = stack.pop(); ${b}} else { stack.pop(); }`)                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| string_template      | (`  state = literal(input, state.pos, '${s}');\n`)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| sequence_template1   | (`${foo}  if (state) { ${bar} }\n`)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| nonterminal_template | (`  state = parse_${n}(input, state.pos);\n`)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| grammar_out_1        | `${r}\n${g}`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| grammar_out_2        | `// This is from a template in peg.org:\n ${r} function parse_char(input, pos) {if (pos >= input.length) return null; return { pos: pos + 1, val: input.charAt(pos) };} function literal(input, pos, string) {if (input.substr(pos, string.length) === string) {return { pos: pos + string.length, val: string };} else return null;} var fs = require(\'fs\'); var grammarfile = process.argv.slice(2)[0]; fs.readFile(grammarfile, function(err, data) {if (err) {throw err;} var out = parse_grammar(data.toString(), 0); console.log(out.val);});` |


#+NAME: labeled_template
#+BEGIN_SRC js
(`${value} if (state) var ${label} = state.val;\n`)
#+END_SRC

#+NAME: result_expr_template
#+BEGIN_SRC js
(`if (state) state.val = ${result};\n`)
#+END_SRC

#+NAME: negation_template
#+BEGIN_SRC js
(`stack.push(state);
   ${t}
   if (state) {
     stack.pop();
     state = null;
   } else { state = stack.pop(); }`)
#+END_SRC

#+NAME: choice_template
#+BEGIN_SRC js
(`  stack.push(state); ${a} if (!state) {state = stack.pop(); ${b}} else { stack.pop(); }`)
#+END_SRC

#+NAME: string_template
#+BEGIN_SRC js
(`  state = literal(input, state.pos, '${s}');\n`)
#+END_SRC

#+NAME: sequence_template1
#+BEGIN_SRC js
(`${foo}  if (state) { ${bar} }\n`)
#+END_SRC

#+NAME: nonterminal_template
#+BEGIN_SRC js
(`  state = parse_${n}(input, state.pos);\n`)
#+END_SRC

#+NAME: rule_template
#+BEGIN_SRC js
(`// This is from a template in b.peg
function parse_${n}(input, pos) {
      var state = { pos: pos };
      var stack = [];
      // Not sure where this body is coming from
      ${body}
      return state;
}`)
#+END_SRC

#+NAME: grammar_template1
#+BEGIN_SRC js
(`${r}\n${g}`)
#+END_SRC

#+NAME: grammar_template2
#+BEGIN_SRC js
(`// This is from a template in peg.org:
 ${r}
 function parse_char(input, pos) {
   if (pos >= input.length) return null;
   return { pos: pos + 1, val: input.charAt(pos) };
 }
 function literal(input, pos, string) {
   if (input.substr(pos, string.length) === string) {
     return { pos: pos + string.length, val: string };
   } else return null;
 }
 var fs = require(\'fs\');
 var grammarfile = process.argv.slice(2)[0];
 fs.readFile(grammarfile, function(err, data) {
     if (err) {
         throw err; 
     }
     var out = parse_grammar(data.toString(), 0);
     console.log(out.val);
 });`)
#+END_SRC

