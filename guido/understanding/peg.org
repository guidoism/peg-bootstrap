This is my first attempt at literate programming with Org Mode where
I'm trying to create a self-compiling PEG parser.

* The rules

#+TBLNAME: rules
| sp                | <- | ' '                                         |    |                          |   |
|                   | /  | '\n'                                        |    |                          |   |
|                   | /  | '\t'                                        |    |                          | . |
| sps               | <- | sp sps                                      |    |                          |   |
|                   | /  |                                             |    |                          | . |
| rule              | <- | n: name sps '<-' sps body: choice '.' sps   | -> | rule_template            | . |
| grammar           | <- | sps r: rule g: grammar                      | -> | grammar_template1        |   |
|                   | /  | sps r: rule                                 | -> | grammar_template2        | . |
| meta              | <- | '!'                                         |    |                          |   |
|                   | /  | '\''                                        |    |                          |   |
|                   | /  | '<-'                                        |    |                          |   |
|                   | /  | '/'                                         |    |                          |   |
|                   | /  | '.'                                         |    |                          |   |
|                   | /  | '('                                         |    |                          |   |
|                   | /  | ')'                                         |    |                          |   |
|                   | /  | ':'                                         |    |                          |   |
|                   | /  | '->'                                        |    |                          | . |
| name              | <- | c: namechar n: name                         | -> | name_template            |   |
|                   | /  | namechar                                    |    |                          | . |
| namechar          | <- | !meta !sp char                              |    |                          | . |
| term              | <- | labeled                                     |    |                          |   |
|                   | /  | nonterminal                                 |    |                          |   |
|                   | /  | string                                      |    |                          |   |
|                   | /  | negation                                    |    |                          |   |
|                   | /  | parenthesized                               |    |                          | . |
| nonterminal       | <- | n: name sps                                 | -> | nonterminal_template     | . |
| labeled           | <- | label: name sps ':' sps value: term         | -> | labeled_template         | . |
| sequence          | <- | foo: term  bar: sequence                    | -> | sequence_template1       |   |
|                   | /  | result_expression                           |    |                          |   |
|                   | /  |                                             | -> | sequence_template2       | . |
| string            | <- | '\'' s: stringcontents '\'' sps             | -> | string_template          | . |
| stringcontents    | <- | !'\\' !'\'' c: char s: stringcontents       | -> | stringcontents_template1 |   |
|                   | /  | b: '\\' c: char s: stringcontents           | -> | stringcontents_template2 |   |
|                   | /  |                                             | -> | stringcontents_template3 | . |
| choice            | <- | a: sequence '/' sps  b: choice              | -> | choice_template          |   |
|                   | /  | sequence                                    |    |                          | . |
| negation          | <- | '!' sps t: term                             | -> | negation_template        | . |
| result_expression | <- | '->' sps result: expr sps                   | -> | result_expr_template     | . |
| expr              | <- | '(' sps e: exprcontents ')'                 | -> | expr_template            | . |
| exprcontents      | <- | c: (!'(' !')' char / expr)  e: exprcontents | -> | exprcontents_template1   |   |
|                   | /  |                                             | -> | exprcontents_template2   | . |
| parenthesized     | <- | '(' sps body: choice ')' sps                | -> | (body)                   | . |


* Helper scripts to tie everything together at the end
#+PROPERTY: header-args:python :var filename=(buffer-file-name)

#+NAME: pegfile
#+BEGIN_SRC python :var rules=rules :noweb yes
  <<js_src_blocks>>
  name_size = max(len(r[0]) for r in rules)
  out = []
  for (name, larrow, body, rarrow, action, end) in rules:
      if action and action[0] != '(':
	  action = blocks.get(action) or 'NOT FOUND'
      out.append(f"{name.ljust(name_size)} {larrow} {body} {rarrow} {action} {end}")
  output = '\n'.join(out)
  output = output.replace('sps', '_')
  open('literate.a.peg', 'w').write(output)

  out = []
  for (name, larrow, body, rarrow, action, end) in rules:
      if action and action[0] != '(':
	  b_action = f'B.{action}'
	  action = blocks.get(b_action) or blocks.get(action) or 'NOT FOUND'
      out.append(f"{name.ljust(name_size)} {larrow} {body} {rarrow} {action} {end}")
  output = '\n'.join(out)
  output = output.replace('sps', '_')
  open('literate.b.peg', 'w').write(output)

  return output
#+END_SRC

#+RESULTS: pegfile
#+begin_example
sp                <- ' '   
                  / '\n'   
                  / '\t'   .
_               <- sp _   
                  /    .
rule              <- n: name _ '<-' _ body: choice '.' _ -> (format(['function parse_', n, '(input, pos) { var state = { pos: pos }; var stack = []; ',
         body, ' return state; }']))
 .
grammar           <- _ r: rule g: grammar -> (format([r, ' ', g]))
 
                  / _ r: rule -> ('// This is from a template in peg.org:\n' + r +
   ` function parse_char(input, pos) {
     if (pos >= input.length) return null;
     return { pos: pos + 1, val: input.charAt(pos) };
   }
   function literal(input, pos, string) {
     if (input.substr(pos, string.length) === string) {
       return { pos: pos + string.length, val: string };
     } else return null;
   }
   let format = (parts) => parts.join('')
   var fs = require(\'fs\');
   var grammarfile = process.argv.slice(2)[0];
   fs.readFile(grammarfile, function(err, data) {
       if (err) {
	   throw err; 
       }
       var out = parse_grammar(data.toString(), 0);
       console.log(out.val);
   });`)
 .
meta              <- '!'   
                  / '\''   
                  / '<-'   
                  / '/'   
                  / '.'   
                  / '('   
                  / ')'   
                  / ':'   
                  / '->'   .
name              <- c: namechar n: name -> (c + n)
 
                  / namechar   .
namechar          <- !meta !sp char   .
term              <- labeled   
                  / nonterminal   
                  / string   
                  / negation   
                  / parenthesized   .
nonterminal       <- n: name _ -> (format(['state = parse_', n, '(input, state.pos);']))
 .
labeled           <- label: name _ ':' _ value: term -> (format([value, ' if (state) { var ', label, ' = state.val; }']))
 .
sequence          <- foo: term  bar: sequence -> (format([foo, ' if (state) { ', bar, ' } ']))
 
                  / result_expression   
                  /  -> ('')
 .
string            <- '\'' s: stringcontents '\'' _ -> (format(['state = literal(input, state.pos, \'', s, '\');']))
 .
stringcontents    <- !'\\' !'\'' c: char s: stringcontents -> (c + s)
 
                  / b: '\\' c: char s: stringcontents -> (b + c + s)
 
                  /  -> ('')
 .
choice            <- a: sequence '/' _  b: choice -> (format(['stack.push(state); ',
	      a,
	      ' if (!state) {state = stack.pop(); ',
	      b,
	      '} else { stack.pop(); }']))
 
                  / sequence   .
negation          <- '!' _ t: term -> (format([' stack.push(state);', t, 
	   'if (state) { stack.pop(); state = null; }',
	   'else { state = stack.pop(); }']))
 .
result_expression <- '->' _ result: expr _ -> (format(['if (state) { state.val = ', result, '; }']))
 .
expr              <- '(' _ e: exprcontents ')' -> ('(' + e + ')')
 .
exprcontents      <- c: (!'(' !')' char / expr)  e: exprcontents -> (c + e)
 
                  /  -> ('')
 .
parenthesized     <- '(' _ body: choice ')' _ -> (body) .
#+end_example


#+NAME: guido
#+BEGIN_SRC python :var rules=rules
  import re
  out = ['\input cwebmac \halign{\strut\hfil#\hfil\quad&#\hfil\quad&#\hfil\quad&#\hfil\quad&\hfil#\cr']
  for (name, larrow, body, rarrow, action, end) in rules:
      if larrow == '<-':
	  larrow = '\\leftarrow '
      if rarrow == '->':
	  rarrow = '\\rightarrow '
      body = body.replace('\\', '\\\\')
      #body = re.sub(r"'(\\\'|[^']+)'", r"\\vb{\\tt '\1'}", body)
      out.append(f"{name} & {larrow} & {body} & {rarrow} & {end} \cr")
  out.append('}\n\\bye\n')
  output = '\n'.join(out)
  open('output.tex', 'w').write(output)
  return output
#+END_SRC

#+RESULTS: guido
#+begin_example
\input cwebmac \halign{\strut\hfil#\hfil\quad&#\hfil\quad&#\hfil\quad&#\hfil\quad&\hfil#\cr
sp & \leftarrow  & ' ' &  &  \cr
 & / & '\\n' &  &  \cr
 & / & '\\t' &  & . \cr
sps & \leftarrow  & sp sps &  &  \cr
 & / &  &  & . \cr
rule & \leftarrow  & n: name sps '<-' sps body: choice '.' sps & \rightarrow  & . \cr
grammar & \leftarrow  & sps r: rule g: grammar & \rightarrow  &  \cr
 & / & sps r: rule & \rightarrow  & . \cr
meta & \leftarrow  & '!' &  &  \cr
 & / & '\\'' &  &  \cr
 & / & '<-' &  &  \cr
 & / & '/' &  &  \cr
 & / & '.' &  &  \cr
 & / & '(' &  &  \cr
 & / & ')' &  &  \cr
 & / & ':' &  &  \cr
 & / & '->' &  & . \cr
name & \leftarrow  & c: namechar n: name & \rightarrow  &  \cr
 & / & namechar &  & . \cr
namechar & \leftarrow  & !meta !sp char &  & . \cr
term & \leftarrow  & labeled &  &  \cr
 & / & nonterminal &  &  \cr
 & / & string &  &  \cr
 & / & negation &  &  \cr
 & / & parenthesized &  & . \cr
nonterminal & \leftarrow  & n: name sps & \rightarrow  & . \cr
labeled & \leftarrow  & label: name sps ':' sps value: term & \rightarrow  & . \cr
sequence & \leftarrow  & foo: term  bar: sequence & \rightarrow  &  \cr
 & / & resultexpression &  &  \cr
 & / &  & \rightarrow  & . \cr
string & \leftarrow  & '\\'' s: stringcontents '\\'' sps & \rightarrow  & . \cr
stringcontents & \leftarrow  & !'\\\\' !'\\'' c: char s: stringcontents & \rightarrow  &  \cr
 & / & b: '\\\\' c: char s: stringcontents & \rightarrow  &  \cr
 & / &  & \rightarrow  & . \cr
choice & \leftarrow  & a: sequence '/' sps  b: choice & \rightarrow  &  \cr
 & / & sequence &  & . \cr
negation & \leftarrow  & '!' sps t: term & \rightarrow  & . \cr
resultexpression & \leftarrow  & '->' sps result: expr sps & \rightarrow  & . \cr
expr & \leftarrow  & '(' sps e: exprcontents ')' & \rightarrow  & . \cr
exprcontents & \leftarrow  & c: (!'(' !')' char / expr)  e: exprcontents & \rightarrow  &  \cr
 & / &  & \rightarrow  & . \cr
parenthesized & \leftarrow  & '(' sps body: choice ')' sps & \rightarrow  & . \cr
}
\bye
#+end_example

We need a way to get the templates that have been broken out into
source blocks in this document. There's probably a better way, but the
easiest thing I could figure out was to read the current file into
memory and use regexes to get at each of the source blocks. This is
probably pretty fragile so we should consider something better.

#+NAME: js_src_blocks
#+BEGIN_SRC python
  import re
  this = open(filename).read()
  blocks = dict(re.findall(r'#\+NAME:\s*(\S+)\s+#\+BEGIN_SRC js\s+(.+?)#\+END_SRC', this, re.MULTILINE|re.DOTALL))
#+END_SRC


* Action Templates

  Note: The `B`-series templates are made to do string interpolation in a way
  closer to other languages and easier to port to C and assembly.

** rule_template

   Each rule is represented and generated as a single function. These
   function need to support recursive and mutually-recusive calls.

   Upon entry, each invocation saves the current position and creates
   a new stack for itself.

   Then the generated body is run and whatever the state is at the end
   is returned to the caller.
   
#+NAME: rule_template
#+BEGIN_SRC js
(`// This is from a template in b.peg
function parse_${n}(input, pos) {
      var state = { pos: pos };
      var stack = [];
      ${body}
      return state;
}`)
#+END_SRC

#+NAME: B.rule_template
#+BEGIN_SRC js
(format(['function parse_', n, '(input, pos) { var state = { pos: pos }; var stack = []; ',
         body, ' return state; }']))
#+END_SRC

#+NAME: C.rule_template
#+BEGIN_SRC js
#+END_SRC

labeled_template:
#+NAME: labeled_template
#+BEGIN_SRC js
(`${value} if (state) { var ${label} = state.val; }\n`)
#+END_SRC

#+NAME: B.labeled_template
#+BEGIN_SRC js
(format([value, ' if (state) { var ', label, ' = state.val; }']))
#+END_SRC

result_expr_template:
#+NAME: result_expr_template
#+BEGIN_SRC js
(`if (state) state.val = ${result};\n`)
#+END_SRC

#+NAME: B.result_expr_template
#+BEGIN_SRC js
(format(['if (state) { state.val = ', result, '; }']))
#+END_SRC

negation_template:
#+NAME: negation_template
#+BEGIN_SRC js
(` stack.push(state);
   ${t}
   if (state) {
     stack.pop();
     state = null;
   } else { state = stack.pop(); }`)
#+END_SRC

#+NAME: B.negation_template
#+BEGIN_SRC js
  (format([' stack.push(state);', t, 
	   'if (state) { stack.pop(); state = null; }',
	   'else { state = stack.pop(); }']))
#+END_SRC

choice_template:
#+NAME: choice_template
#+BEGIN_SRC js
(`stack.push(state); ${a} if (!state) {state = stack.pop(); ${b}} else { stack.pop(); }`)
#+END_SRC

#+NAME: B.choice_template
#+BEGIN_SRC js
     (format(['stack.push(state); ',
	      a,
	      ' if (!state) {state = stack.pop(); ',
	      b,
	      '} else { stack.pop(); }']))
#+END_SRC

string_template:
#+NAME: string_template
#+BEGIN_SRC js
(`state = literal(input, state.pos, '${s}');\n`)
#+END_SRC

#+NAME: B.string_template
#+BEGIN_SRC js
(format(['state = literal(input, state.pos, \'', s, '\');']))
#+END_SRC

sequence_template1:
#+NAME: sequence_template1
#+BEGIN_SRC js
(`${foo}  if (state) { ${bar} }\n`)
#+END_SRC

#+NAME: B.sequence_template1
#+BEGIN_SRC js
(format([foo, ' if (state) { ', bar, ' } ']))
#+END_SRC

sequence_template2:
#+NAME: sequence_template2
#+BEGIN_SRC js
('')
#+END_SRC

stringcontents_template1:
#+NAME: stringcontents_template1
#+BEGIN_SRC js
(c + s)
#+END_SRC

stringcontents_template2:
#+NAME: stringcontents_template2
#+BEGIN_SRC js
(b + c + s)
#+END_SRC

stringcontents_template3:
#+NAME: stringcontents_template3
#+BEGIN_SRC js
('')
#+END_SRC

expr_template:
#+NAME: expr_template
#+BEGIN_SRC js
('(' + e + ')')
#+END_SRC

exprcontents_template1:
#+NAME: exprcontents_template1
#+BEGIN_SRC js
(c + e)
#+END_SRC

exprcontents_template2:
#+NAME: exprcontents_template2
#+BEGIN_SRC js
('')
#+END_SRC

nonterminal_template:
#+NAME: nonterminal_template
#+BEGIN_SRC js
(`state = parse_${n}(input, state.pos);\n`)
#+END_SRC

#+NAME: B.nonterminal_template
#+BEGIN_SRC js
(format(['state = parse_', n, '(input, state.pos);']))
#+END_SRC

grammar_template1:
#+NAME: grammar_template1
#+BEGIN_SRC js
(`${r}\n${g}`)
#+END_SRC

#+NAME: B.grammar_template1
#+BEGIN_SRC js
(format([r, ' ', g]))
#+END_SRC

grammar_template2:
#+NAME: grammar_template2
#+BEGIN_SRC js
  ('// This is from a template in peg.org:\n' + r +
   ` function parse_char(input, pos) {
     if (pos >= input.length) return null;
     return { pos: pos + 1, val: input.charAt(pos) };
   }
   function literal(input, pos, string) {
     if (input.substr(pos, string.length) === string) {
       return { pos: pos + string.length, val: string };
     } else return null;
   }
   let format = (parts) => parts.join('')
   var fs = require(\'fs\');
   var grammarfile = process.argv.slice(2)[0];
   fs.readFile(grammarfile, function(err, data) {
       if (err) {
	   throw err; 
       }
       var out = parse_grammar(data.toString(), 0);
       console.log(out.val);
   });`)
#+END_SRC

name_template:
#+NAME: name_template
#+BEGIN_SRC js
(c + n)
#+END_SRC




