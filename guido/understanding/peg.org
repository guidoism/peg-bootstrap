This is my first attempt at literate programming with Org Mode where
I'm trying to create a self-compiling PEG parser.

* The rules

#+TBLNAME: rules
| sp                | <- | ' '                                         |    |                          |   |
|                   | /  | '\n'                                        |    |                          |   |
|                   | /  | '\t'                                        |    |                          | . |
| sps               | <- | sp sps                                      |    |                          |   |
|                   | /  |                                             |    |                          | . |
| rule              | <- | n: name sps '<-' sps body: choice '.' sps   | -> | rule_template            | . |
| grammar           | <- | sps r: rule g: grammar                      | -> | grammar_template1        |   |
|                   | /  | sps r: rule                                 | -> | grammar_template2        | . |
| meta              | <- | '!'                                         |    |                          |   |
|                   | /  | '\''                                        |    |                          |   |
|                   | /  | '<-'                                        |    |                          |   |
|                   | /  | '/'                                         |    |                          |   |
|                   | /  | '.'                                         |    |                          |   |
|                   | /  | '('                                         |    |                          |   |
|                   | /  | ')'                                         |    |                          |   |
|                   | /  | ':'                                         |    |                          |   |
|                   | /  | '->'                                        |    |                          | . |
| name              | <- | c: namechar n: name                         | -> | name_template            |   |
|                   | /  | namechar                                    |    |                          | . |
| namechar          | <- | !meta !sp char                              |    |                          | . |
| term              | <- | labeled                                     |    |                          |   |
|                   | /  | nonterminal                                 |    |                          |   |
|                   | /  | string                                      |    |                          |   |
|                   | /  | negation                                    |    |                          |   |
|                   | /  | parenthesized                               |    |                          | . |
| nonterminal       | <- | n: name sps                                 | -> | nonterminal_template     | . |
| labeled           | <- | label: name sps ':' sps value: term         | -> | labeled_template         | . |
| sequence          | <- | foo: term  bar: sequence                    | -> | sequence_template1       |   |
|                   | /  | result_expression                           |    |                          |   |
|                   | /  |                                             | -> | sequence_template2       | . |
| string            | <- | '\'' s: stringcontents '\'' sps             | -> | string_template          | . |
| stringcontents    | <- | !'\\' !'\'' c: char s: stringcontents       | -> | stringcontents_template1 |   |
|                   | /  | b: '\\' c: char s: stringcontents           | -> | stringcontents_template2 |   |
|                   | /  |                                             | -> | stringcontents_template3 | . |
| choice            | <- | a: sequence '/' sps  b: choice              | -> | choice_template          |   |
|                   | /  | sequence                                    |    |                          | . |
| negation          | <- | '!' sps t: term                             | -> | negation_template        | . |
| result_expression | <- | '->' sps result: expr sps                   | -> | result_expr_template     | . |
| expr              | <- | '(' sps e: exprcontents ')'                 | -> | expr_template            | . |
| exprcontents      | <- | c: (!'(' !')' char / expr)  e: exprcontents | -> | exprcontents_template1   |   |
|                   | /  |                                             | -> | exprcontents_template2   | . |
| parenthesized     | <- | '(' sps body: choice ')' sps                | -> | (body)                   | . |


* Helper scripts to tie everything together at the end
#+PROPERTY: header-args:python :var filename=(buffer-file-name)

#+NAME: pegfile
#+BEGIN_SRC python :var rules=rules :noweb yes
  <<js_src_blocks>>
  name_size = max(len(r[0]) for r in rules)
  out = []
  for (name, larrow, body, rarrow, action, end) in rules:
      if action and action[0] != '(':
	  action = blocks.get(action) or 'NOT FOUND'
      out.append(f"{name.ljust(name_size)} {larrow} {body} {rarrow} {action} {end}")
  output = '\n'.join(out)
  output = output.replace('sps', '_')
  open('literate.a.peg', 'w').write(output)
  return output
#+END_SRC

#+RESULTS: pegfile
#+begin_example
sp                <- ' '   
                  / '\n'   
                  / '\t'   .
_               <- sp _   
                  /    .
rule              <- n: name _ '<-' _ body: choice '.' _ -> (`// This is from a template in b.peg
function parse_${n}(input, pos) {
      var state = { pos: pos };
      var stack = [];
      // Not sure where this body is coming from
      ${body}
      return state;
}`)
 .
grammar           <- _ r: rule g: grammar -> (`${r}\n${g}`)
 
                  / _ r: rule -> (`// This is from a template in peg.org:
 ${r}
 function parse_char(input, pos) {
   if (pos >= input.length) return null;
   return { pos: pos + 1, val: input.charAt(pos) };
 }
 function literal(input, pos, string) {
   if (input.substr(pos, string.length) === string) {
     return { pos: pos + string.length, val: string };
   } else return null;
 }
 var fs = require(\'fs\');
 var grammarfile = process.argv.slice(2)[0];
 fs.readFile(grammarfile, function(err, data) {
     if (err) {
         throw err; 
     }
     var out = parse_grammar(data.toString(), 0);
     console.log(out.val);
 });`)
 .
meta              <- '!'   
                  / '\''   
                  / '<-'   
                  / '/'   
                  / '.'   
                  / '('   
                  / ')'   
                  / ':'   
                  / '->'   .
name              <- c: namechar n: name -> (c + n)
 
                  / namechar   .
namechar          <- !meta !sp char   .
term              <- labeled   
                  / nonterminal   
                  / string   
                  / negation   
                  / parenthesized   .
nonterminal       <- n: name _ -> (`  state = parse_${n}(input, state.pos);\n`)
 .
labeled           <- label: name _ ':' _ value: term -> (`${value} if (state) var ${label} = state.val;\n`)
 .
sequence          <- foo: term  bar: sequence -> (`${foo}  if (state) { ${bar} }\n`)
 
                  / result_expression   
                  /  -> ('')
 .
string            <- '\'' s: stringcontents '\'' _ -> (`  state = literal(input, state.pos, '${s}');\n`)
 .
stringcontents    <- !'\\' !'\'' c: char s: stringcontents -> (c + s)
 
                  / b: '\\' c: char s: stringcontents -> (b + c + s)
 
                  /  -> ('')
 .
choice            <- a: sequence '/' _  b: choice -> (`  stack.push(state); ${a} if (!state) {state = stack.pop(); ${b}} else { stack.pop(); }`)
 
                  / sequence   .
negation          <- '!' _ t: term -> (`stack.push(state);
   ${t}
   if (state) {
     stack.pop();
     state = null;
   } else { state = stack.pop(); }`)
 .
result_expression <- '->' _ result: expr _ -> (`if (state) state.val = ${result};\n`)
 .
expr              <- '(' _ e: exprcontents ')' -> (`(${e})`)
 .
exprcontents      <- c: (!'(' !')' char / expr)  e: exprcontents -> (c + e)
 
                  /  -> ('')
 .
parenthesized     <- '(' _ body: choice ')' _ -> (body) .
#+end_example


#+NAME: guido
#+BEGIN_SRC python :var rules=rules
  import re
  out = ['\input cwebmac \halign{\strut\hfil#\hfil\quad&#\hfil\quad&#\hfil\quad&#\hfil\quad&\hfil#\cr']
  for (name, larrow, body, rarrow, action, end) in rules:
      if larrow == '<-':
	  larrow = '\\leftarrow '
      if rarrow == '->':
	  rarrow = '\\rightarrow '
      body = body.replace('\\', '\\\\')
      #body = re.sub(r"'(\\\'|[^']+)'", r"\\vb{\\tt '\1'}", body)
      out.append(f"{name} & {larrow} & {body} & {rarrow} & {end} \cr")
  out.append('}\n\\bye\n')
  output = '\n'.join(out)
  open('output.tex', 'w').write(output)
  return output
#+END_SRC

#+RESULTS: guido
#+begin_example
\input cwebmac \halign{\strut\hfil#\hfil\quad&#\hfil\quad&#\hfil\quad&#\hfil\quad&\hfil#\cr
sp & \leftarrow  & ' ' &  &  \cr
 & / & '\\n' &  &  \cr
 & / & '\\t' &  & . \cr
sps & \leftarrow  & sp sps &  &  \cr
 & / &  &  & . \cr
rule & \leftarrow  & n: name sps '<-' sps body: choice '.' sps & \rightarrow  & . \cr
grammar & \leftarrow  & sps r: rule g: grammar & \rightarrow  &  \cr
 & / & sps r: rule & \rightarrow  & . \cr
meta & \leftarrow  & '!' &  &  \cr
 & / & '\\'' &  &  \cr
 & / & '<-' &  &  \cr
 & / & '/' &  &  \cr
 & / & '.' &  &  \cr
 & / & '(' &  &  \cr
 & / & ')' &  &  \cr
 & / & ':' &  &  \cr
 & / & '->' &  & . \cr
name & \leftarrow  & c: namechar n: name & \rightarrow  &  \cr
 & / & namechar &  & . \cr
namechar & \leftarrow  & !meta !sp char &  & . \cr
term & \leftarrow  & labeled &  &  \cr
 & / & nonterminal &  &  \cr
 & / & string &  &  \cr
 & / & negation &  &  \cr
 & / & parenthesized &  & . \cr
nonterminal & \leftarrow  & n: name sps & \rightarrow  & . \cr
labeled & \leftarrow  & label: name sps ':' sps value: term & \rightarrow  & . \cr
sequence & \leftarrow  & foo: term  bar: sequence & \rightarrow  &  \cr
 & / & resultexpression &  &  \cr
 & / &  & \rightarrow  & . \cr
string & \leftarrow  & '\\'' s: stringcontents '\\'' sps & \rightarrow  & . \cr
stringcontents & \leftarrow  & !'\\\\' !'\\'' c: char s: stringcontents & \rightarrow  &  \cr
 & / & b: '\\\\' c: char s: stringcontents & \rightarrow  &  \cr
 & / &  & \rightarrow  & . \cr
choice & \leftarrow  & a: sequence '/' sps  b: choice & \rightarrow  &  \cr
 & / & sequence &  & . \cr
negation & \leftarrow  & '!' sps t: term & \rightarrow  & . \cr
resultexpression & \leftarrow  & '->' sps result: expr sps & \rightarrow  & . \cr
expr & \leftarrow  & '(' sps e: exprcontents ')' & \rightarrow  & . \cr
exprcontents & \leftarrow  & c: (!'(' !')' char / expr)  e: exprcontents & \rightarrow  &  \cr
 & / &  & \rightarrow  & . \cr
parenthesized & \leftarrow  & '(' sps body: choice ')' sps & \rightarrow  & . \cr
}
\bye
#+end_example

We need a way to get the templates that have been broken out into
source blocks in this document. There's probably a better way, but the
easiest thing I could figure out was to read the current file into
memory and use regexes to get at each of the source blocks. This is
probably pretty fragile so we should consider something better.

#+NAME: js_src_blocks
#+BEGIN_SRC python
  import re
  this = open(filename).read()
  blocks = dict(re.findall(r'#\+NAME:\s*(\S+)\s+#\+BEGIN_SRC js\s+(.+?)#\+END_SRC', this, re.MULTILINE|re.DOTALL))
#+END_SRC


* Action Templates

  labeled_template:
#+NAME: labeled_template
#+BEGIN_SRC js
(`${value} if (state) var ${label} = state.val;\n`)
#+END_SRC

result_expr_template:
#+NAME: result_expr_template
#+BEGIN_SRC js
(`if (state) state.val = ${result};\n`)
#+END_SRC

negation_template:
#+NAME: negation_template
#+BEGIN_SRC js
(`stack.push(state);
   ${t}
   if (state) {
     stack.pop();
     state = null;
   } else { state = stack.pop(); }`)
#+END_SRC

choice_template:
#+NAME: choice_template
#+BEGIN_SRC js
(`  stack.push(state); ${a} if (!state) {state = stack.pop(); ${b}} else { stack.pop(); }`)
#+END_SRC

string_template:
#+NAME: string_template
#+BEGIN_SRC js
(`  state = literal(input, state.pos, '${s}');\n`)
#+END_SRC

sequence_template1:
#+NAME: sequence_template1
#+BEGIN_SRC js
(`${foo}  if (state) { ${bar} }\n`)
#+END_SRC

sequence_template2:
#+NAME: sequence_template2
#+BEGIN_SRC js
('')
#+END_SRC

stringcontents_template1:
#+NAME: stringcontents_template1
#+BEGIN_SRC js
(c + s)
#+END_SRC

stringcontents_template2:
#+NAME: stringcontents_template2
#+BEGIN_SRC js
(b + c + s)
#+END_SRC

stringcontents_template3:
#+NAME: stringcontents_template3
#+BEGIN_SRC js
('')
#+END_SRC

expr_template:
#+NAME: expr_template
#+BEGIN_SRC js
(`(${e})`)
#+END_SRC

exprcontents_template1:
#+NAME: exprcontents_template1
#+BEGIN_SRC js
(c + e)
#+END_SRC

exprcontents_template2:
#+NAME: exprcontents_template2
#+BEGIN_SRC js
('')
#+END_SRC

nonterminal_template:
#+NAME: nonterminal_template
#+BEGIN_SRC js
(`  state = parse_${n}(input, state.pos);\n`)
#+END_SRC

rule_template:
#+NAME: rule_template
#+BEGIN_SRC js
(`// This is from a template in b.peg
function parse_${n}(input, pos) {
      var state = { pos: pos };
      var stack = [];
      // Not sure where this body is coming from
      ${body}
      return state;
}`)
#+END_SRC

grammar_template1:
#+NAME: grammar_template1
#+BEGIN_SRC js
(`${r}\n${g}`)
#+END_SRC

grammar_template2:
#+NAME: grammar_template2
#+BEGIN_SRC js
(`// This is from a template in peg.org:
 ${r}
 function parse_char(input, pos) {
   if (pos >= input.length) return null;
   return { pos: pos + 1, val: input.charAt(pos) };
 }
 function literal(input, pos, string) {
   if (input.substr(pos, string.length) === string) {
     return { pos: pos + string.length, val: string };
   } else return null;
 }
 var fs = require(\'fs\');
 var grammarfile = process.argv.slice(2)[0];
 fs.readFile(grammarfile, function(err, data) {
     if (err) {
         throw err; 
     }
     var out = parse_grammar(data.toString(), 0);
     console.log(out.val);
 });`)
#+END_SRC

name_template:
#+NAME: name_template
#+BEGIN_SRC js
(c + n)
#+END_SRC


