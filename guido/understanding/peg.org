This is my first attempt at literate programming with Org Mode where
I'm trying to create a self-compiling PEG parser.

#+NAME: guido
#+BEGIN_SRC python :var rules=rules
  out = []
  for (name, larrow, body, rarrow, action, end) in rules:
    out.append(f"{name} {larrow} {body} {rarrow} {end}")
  return '\n'.join(out)
#+END_SRC

#+RESULTS: guido
#+begin_example
sp <- ' '  
 / '\n'  
 / '\t'  .
sps <- sp sps  
 /   .
rule <- n: name sps '<-' sps body: choice '.' sps -> .
grammar <- sps r: rule g: grammar -> 
 / sps r: rule -> .
meta <- '!'  
 / '\''  
 / '<-'  
 / '/'  
 / '.'  
 / '('  
 / ')'  
 / ':'  
 / '->'  .
name <- c: namechar n: name -> 
 / namechar  .
namechar <- !meta !sp char  .
term <- labeled  
 / nonterminal  
 / string  
 / negation  
 / parenthesized  .
nonterminal <- n: name sps -> .
labeled <- label: name sps ':' sps value: term -> .
sequence <- foo: term  bar: sequence -> 
 / result_expression  
 /  -> .
string <- '\'' s: stringcontents '\'' sps -> .
stringcontents <- !'\\' !'\'' c: char s: stringcontents -> 
 / b: '\\' c: char s: stringcontents -> 
 /  -> .
choice <- a: sequence '/' sps  b: choice -> 
 / sequence  .
negation <- '!' sps t: term -> .
result_expression <- '->' sps result: expr sps -> .
expr <- '('_ e: exprcontents ')' -> .
exprcontents <- c: (!'(' !')' char / expr)  e: exprcontents -> 
 /  -> .
parenthesized <- '(' sps body: choice ')' sps -> .
#+end_example


#+TBLNAME: rules
| sp                | <- | ' '                                         |    |                     |   |
|                   | /  | '\n'                                        |    |                     |   |
|                   | /  | '\t'                                        |    |                     | . |
| sps               | <- | sp sps                                      |    |                     |   |
|                   | /  |                                             |    |                     | . |
| rule              | <- | n: name sps '<-' sps body: choice '.' sps   | -> | ruletemplate        | . |
| grammar           | <- | sps r: rule g: grammar                      | -> | grammartemplate_1   |   |
|                   | /  | sps r: rule                                 | -> | grammartemplate_2   | . |
| meta              | <- | '!'                                         |    |                     |   |
|                   | /  | '\''                                        |    |                     |   |
|                   | /  | '<-'                                        |    |                     |   |
|                   | /  | '/'                                         |    |                     |   |
|                   | /  | '.'                                         |    |                     |   |
|                   | /  | '('                                         |    |                     |   |
|                   | /  | ')'                                         |    |                     |   |
|                   | /  | ':'                                         |    |                     |   |
|                   | /  | '->'                                        |    |                     | . |
| name              | <- | c: namechar n: name                         | -> | (c + n)             |   |
|                   | /  | namechar                                    |    |                     | . |
| namechar          | <- | !meta !sp char                              |    |                     | . |
| term              | <- | labeled                                     |    |                     |   |
|                   | /  | nonterminal                                 |    |                     |   |
|                   | /  | string                                      |    |                     |   |
|                   | /  | negation                                    |    |                     |   |
|                   | /  | parenthesized                               |    |                     | . |
| nonterminal       | <- | n: name sps                                 | -> | nonterminaltemplate | . |
| labeled           | <- | label: name sps ':' sps value: term         | -> | labeledtemplate     | . |
| sequence          | <- | foo: term  bar: sequence                    | -> | sequencetemplate1   |   |
|                   | /  | result_expression                           |    |                     |   |
|                   | /  |                                             | -> | ('')                | . |
| string            | <- | '\'' s: stringcontents '\'' sps             | -> | stringtemplate      | . |
| stringcontents    | <- | !'\\' !'\'' c: char s: stringcontents       | -> | (c + s)             |   |
|                   | /  | b: '\\' c: char s: stringcontents           | -> | (b + c + s)         |   |
|                   | /  |                                             | -> | ('')                | . |
| choice            | <- | a: sequence '/' sps  b: choice              | -> | choicetemplate      |   |
|                   | /  | sequence                                    |    |                     | . |
| negation          | <- | '!' sps t: term                             | -> | negationtemplate    | . |
| result_expression | <- | '->' sps result: expr sps                   | -> | resultexprtemplate  | . |
| expr              | <- | '('_ e: exprcontents ')'                    | -> | (`(${e})`)          | . |
| exprcontents      | <- | c: (!'(' !')' char / expr)  e: exprcontents | -> | (c + e)             |   |
|                   | /  |                                             | -> | ('')                | . |
| parenthesized     | <- | '(' sps body: choice ')' sps                | -> | (body)              | . |


#+NAME: result_expr_template
#+BEGIN_SRC js
(`if (state) state.val = ${result};\n`)
#+END_SRC

#+NAME: negation_template
#+BEGIN_SRC js
(`stack.push(state);
   ${t}
   if (state) {
     stack.pop();
     state = null;
   } else { state = stack.pop(); }`)
#+END_SRC

#+NAME: choice_template
#+BEGIN_SRC js
(`  stack.push(state);
    ${a}
    if (!state) {
      state = stack.pop();
      ${b}
    } else { stack.pop(); }`)
#+END_SRC

#+NAME: string_template
#+BEGIN_SRC js
(`  state = literal(input, state.pos, '${s}');\n`) .
#+END_SRC

#+NAME: sequence_template1
#+BEGIN_SRC js
(`${foo}  if (state) { ${bar} }\n`)
#+END_SRC

#+NAME: nonterminal_template
#+BEGIN_SRC js
(`  state = parse_${n}(input, state.pos);\n`)
#+END_SRC

#+NAME: grammar_out_1
#+BEGIN_SRC js
`${r}\n${g}`
#+END_SRC

#+NAME: grammar_out_2
#+BEGIN_SRC js
`// This is from a template in peg.org:
 ${r}
 function parse_char(input, pos) {
   if (pos >= input.length) return null;
   return { pos: pos + 1, val: input.charAt(pos) };
 }
 function literal(input, pos, string) {
   if (input.substr(pos, string.length) === string) {
     return { pos: pos + string.length, val: string };
   } else return null;
 }
 var fs = require(\'fs\');
 var grammarfile = process.argv.slice(2)[0];
 fs.readFile(grammarfile, function(err, data) {
     if (err) {
         throw err; 
     }
     var out = parse_grammar(data.toString(), 0);
     console.log(out.val);
 });`
#+END_SRC

