This is an attempt to transform the low-level javascript code from
peg.org to MMIX. I'd also like to come up with a better organization
and way to run it.

We will tweak the original MMIXAL a bit to allow for more flexible
code generation. The first change is that we will use the standard
colon after the label name and ignore leading whitespace.

It's not going to be easy to do string interpolation in assembly
so we will generate a template language that includes line seperated
strings and variables.

** Initialization
#+name: initialization
#+begin_src peg-template
input   GREG 0                 % Location of the input string
state   GREG 0                 % Tuple of (valid, value, pos)
key     GREG 0                 % String handle to the key to be saved
value   GREG 0                 % String handle to the value to be saved
fn      IS   $0                % Set by each function to its function id
ret     IS   $1                % Used to save rJ during PUSHJ calls
VALID   IS   #8000000000000000 % One with a bunch of zeros
#+end_src

** Rule

We will start with the /rule/ rule since it's the most interesting.
   
The state object keeps track of: 1. Is this parse currently
valid?, 2. What is the current position in the input?, and 3. Is there
a value associated with the state?

We will use a full octa for the state object and carefully select
which bits get used for what purpose to ease testing with minimal
bit shuffling.

We will place the valid flag on the left-most bit allowing us to
branch on negative (i.e., if state is negative then it's valid).

We will place the pos on the right-most bits so we can just mask
off the left bits to provide a useful pos.

And value will go in the middle. Since we can't fit most strings in
those few bytes in the middle we will use it as a handle or index into
the string buffer. If it makes sense we might also include a flag and
potentially inline short strings but that might be more complexity for
too little gain.

#+name: rule
#+begin_src peg-template
parse_<<name>>:  SET fn,<<new-fn>>   % Each function gets a unique id
                 OR  state,VALID,pos % Initialize state with valid flag and pos
<<body>>
                 POP 1,0             % Return to caller
#+end_src

** Labeled

/Labeled/ is another interesting rule as it mixes setvar and getvar in
both the context where we are generating the code to be generating and
where we are running the generating code.
   
#+name: labeled
#+begin_src peg-template
<<value>>
     BNN    state,1F      % Negative is valid, so skip to the end if it's not
     SET    ret,rJ        % Save the current return address before the call
     SETSTR key,<<label>> % SETSTR is a /pseudo instruction/ that tells tangle
                          % .to create a string in the data segment using the string
                          % .in the variable and replace it with the octa handle.
     ANDN   t,state,VALID % Mask out the valid bit by ANDing the complement of VALID
     SR     value,t,24    % Shift the result to the proper place in the word
     PUSHJ  ret,SetVar    % Set the variable
1H:  
#+end_src


